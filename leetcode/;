from typing import List

class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        # find a node without an edge, must exist, then do dfs to find length between it and every other node
        # then find max
        # actually, can't you pick any node?
        # if the lengths are equidistant already, you win, if not sum the highest two

        edge_map = {i: set() for i in range(n)}
        for a, b in edges:
            edge_map[a].add(b)
            edge_map[b].add(a)

        distances = {}
        self.dfs(0, 0, edge_map, distances)

        leaf_node = max(distances.items(), key=lambda x: x[1])[0]
        distances = {}
        self.dfs(leaf_node, 0, edge_map, distances)

        furthest_node= max(distances.items(), key=lambda x: x[1])[0]

        find_path = self.dfs(leaf_node, furthest_node, edge_map)
        print(find_path)
        return []

    def dfs(self, node: int, step: int, edge_map: dict[int, set[int]], distances: dict[int, int]):
        if node in distances:
            return distances[node]

        distances[node] = step
        for neighbor in edge_map[node]:
            self.dfs(neighbor, step + 1, edge_map, distances)

    def find_path(self, start: int, end: int, edge_map: dict[int, set[int]]) -> list[int]:
        if start == end:
            return [end]

sol = Solution()
print(sol.findMinHeightTrees(4, [[1,0],[1,2],[1,3]]))
print(sol.findMinHeightTrees(6, [[3,0],[3,1],[3,2],[3,4],[5,4]]))
